# Test types

## Context
Each team and individual has their own unique understanding on what constitutes a particular test type. Developers, missing wider and historical context, over the years, have had countless debates on what is a system test vs end-to-end, whether performance tests are just acceptance tests, whether unit tests are useful, etc. This leads to inconsistent testing strategies, difficult to implement and audit test suites, and bugs slipping past.

## Decision
We will use the following definitions of test types (ordered roughly in the order they should be run):

- Unit tests, are small, inexpensive tests that test small units of code in your modules without any external dependencies. Unit tests make the most sense when you consider a working arrangement in which two or more developers, separately, are working on separate modules, in a non-high-level language, without any frameworks, e.g. close-to-metal development. They are meant to validate that their modules work as intended, before they begin integrating them. This is where mocking comes in, as any calls to functions outside the module containing the unit under test, must be mocked. With the advent of high level programming languages like Python, and frameworks like Django, individual modules are given little attention as they are much smaller and faster to develop, and as a result, developers mental model when considering systems has shifted to thinking in terms of layers (presentation, usecase, business, persistence, db), rather than individual modules. Because of this, coupled with how easy to break, and disposable unit tests are, you will usually see very few of them, reserved for the most sensitive, immutable or complex units of your application.
- Integration tests, just like unit tests, make the most sense when considering a working arrangement in which two or more developers, separately, are working on separate modules, in a non-high-level language, without any frameworks, e.g. close-to-metal development. Once those modules are integrated, integration tests must be written to validate that those modules work together. As an example, one developer may be writing a low level HTTP client in one module, and another developer writing higher abstraction functions in a separate module which utilize that HTTP client. If the HTTP client raises an error when it receives a 404, which the caller does not handle, you have an integration error which should be caught by the integration tests. Unless you're looking at a close-to-metal project, you should see few if any integration tests. Because of modern high languages, and frameworks, we rarely have a working arrangement as mentioned earlier, and functional tests are enough to exercise the whole system.
- Property tests are a type of unit or functional test, used to validate the invariants of a component under test. [For example, a property test may be used to validate that a function which re-orders a list, always returns a list containing the same values that were there originally](https://fsharpforfunandprofit.com/posts/property-based-testing-2/#the-more-things-change-the-more-they-stay-the-same). To implement property tests, you will require a library, such as [QuickCheck](https://hackage.haskell.org/package/QuickCheck) for Haskell or [Hypothesis](https://hypothesis.readthedocs.io/en/latest/) for Python. Although property tests are a type of unit or functional test, they are much slower and require specialized tooling and therefore get their own type. Property testing, while very powerful, is a new discipline and as such not many resources exist online to assist with good property test design. The lack of online resources coupled with few units ever containing strong invariants, results in projects normally having just a few property tests.
- Functional tests are black-box tests that base their test cases on the specification of the component under test. Interfaces are tested by feeding them input, examining their output and side effects, and internal program structure is rarely considered. Unless working with close-to-metal systems, the majority of your tests will be functional, as they exercise the whole internal program structure, and yield the best ROI of all the test types.
- Security tests, as the name states, contain tests that ensure the security of the system. This may be testing for SQL injections or PII leakage in a Python webserver, or ensuring that a developer did not request for a public S3 bucket in a Terraform project. Although security tests can be encompassed within unit, integration and other types of tests, they get their own type to alleviate security concerns and simplify auditing and penetration testing efforts. Many security tests will be introduced into a project in a pre-packaged form such as a 3rd party tool like [tfsec](https://github.com/aquasecurity/tfsec), or an internal, generic pen-testing suite written by your security team.
- System tests ensure that a system, which is run similar to, or identical, to how it is intended to be run in production, actually works. While functional tests ensure that the internals of a system function correctly, they may not necessarily bring the system up. Therefore, separate system tests are utilized to do black-box testing. Normally, a project will contain very few system tests, usually just a couple that run the server and check that it's healthcheck endpoint returns OK, authentication options are respected, endpoints respond, etc.
- Acceptance tests ensure that the requirements, both functional and non-function, of a project have been met. Acceptance tests can be written by the same team that authored the project, to enforce internal standards (linters, code coverage, etc.) or they can also be written by clients to ensure the delivered product matches the specification. Acceptance tests are usually low priority, and so may contain very few, mostly boilerplate tests, such as linters and static analysis like mypy.
- Performance tests are simply a subcategory of acceptance tests, which ensure that a system behaves as expected under load and meets certain capacity requirements. Although performance tests are a type of acceptance test, we split them out into their own type, as they usually involve multiple purpose-built tools, are much slower than acceptance tests and tend to require a specialized skill-set to implement.

## Consequences
Test suites are auditable and consistent as tests are correctly categorized.
